<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fraccionador de Logs - Trivial IRC</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 20px;
        }
        .container { background: white; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 700px; width: 100%; padding: 40px; animation: slideIn 0.5s ease-out; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(30px);} to { opacity: 1; transform: translateY(0);} }
        h1 { text-align: center; color: #333; margin-bottom: 10px; font-size: 2em; }
        .subtitle { text-align: center; color: #666; margin-bottom: 30px; font-size: 0.9em; }
        .upload-area {
            border: 3px dashed #ddd; padding: 40px; text-align: center; margin-bottom: 30px; border-radius: 15px;
            background-color: #fafafa; cursor: pointer; transition: all 0.3s ease;
        }
        .upload-area:hover, .upload-area.dragover { border-color: #667eea; background-color: #f0f0ff; transform: scale(1.02); }
        .upload-icon { font-size: 3em; margin-bottom: 10px; color: #667eea; }
        .options { margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 10px; }
        .option-group { margin-bottom: 20px; }
        .option-label { display: block; color: #555; margin-bottom: 8px; font-weight: 500; }
        .option-input { width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 1em; }
        .checkbox-group { display: flex; align-items: center; gap: 10px; }
        .checkbox-group input[type="checkbox"] { width: 20px; height: 20px; cursor: pointer; }
        .button { background-color: #007bff; color: white; padding: 15px 25px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; width: 100%; margin: 10px 0; transition: all 0.3s ease; }
        .button:hover { background-color: #0056b3; }
        .button:disabled { background-color: #ccc; cursor: not-allowed; }
        .button.success { background-color: #28a745; }
        .button.success:hover { background-color: #218838; }
        .results { margin-top: 30px; display: none; }
        .results.show { display: block; }
        .file-item { background: #f8f9fa; border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .download-btn { padding: 8px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; transition: background 0.3s ease; }
        .download-btn:hover { background: #5a67d8; }
        .message { padding: 15px; margin: 10px 0; border-radius: 8px; }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .extras-section { background: #f0f4ff; border: 2px solid #667eea; border-radius: 10px; padding: 15px; margin-bottom: 20px; }
        .extras-title { color: #667eea; font-weight: bold; margin-bottom: 10px; }
        .file-selected { background: #e8f5e9; border-color: #4caf50; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìÇ Fraccionador de Logs IRC</h1>
        <p class="subtitle">Limpia y divide tus logs de partidas con an√°lisis estad√≠stico</p>

        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">üìÅ</div>
            <div id="uploadText">Arrastra tu archivo aqu√≠ o haz clic para seleccionar</div>
            <input type="file" id="fileInput" accept=".txt,.log" style="display: none;">
        </div>

        <div class="options">
            <div class="option-group">
                <label class="option-label" for="numPartes">N√∫mero de partes:</label>
                <input type="number" id="numPartes" class="option-input" min="2" max="20" value="4">
            </div>
            <div class="option-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="cleanIRC" checked>
                    <label for="cleanIRC">Limpiar c√≥digos IRC</label>
                </div>
            </div>
            <div class="extras-section">
                <div class="extras-title">üìä An√°lisis Extra (para Cronista)</div>
                <div class="checkbox-group">
                    <input type="checkbox" id="addExtras">
                    <label for="addExtras">A√±adir estad√≠sticas y an√°lisis en cada corte</label>
                </div>
            </div>
        </div>

        <button class="button" id="processBtn" style="display: none;">Procesar Archivo</button>
        <div id="messages"></div>
        <div id="results" class="results"></div>
    </div>

    <script>
        let selectedFile = null;

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadText = document.getElementById('uploadText');
        const processBtn = document.getElementById('processBtn');
        const messages = document.getElementById('messages');
        const results = document.getElementById('results');

        uploadArea.onclick = function(){ fileInput.click(); };
        uploadArea.ondragover = function(e){ e.preventDefault(); uploadArea.classList.add('dragover'); };
        uploadArea.ondragleave = function(e){ e.preventDefault(); uploadArea.classList.remove('dragover'); };
        uploadArea.ondrop = function(e){
            e.preventDefault(); uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) handleFile(files[0]);
        };
        fileInput.onchange = function(e){ if (e.target.files.length > 0) handleFile(e.target.files[0]); };
        processBtn.onclick = function(){ processLog(); };

        class AnalizadorPartida {
            constructor(){
                this.equipos = {};
                this.jugadorEquipo = {};
                this.botNick = null;
                this.jugadoresActivos = new Set();
                this.contenidoCompleto = '';
            }

            identificarBot(contenido){
                this.contenidoCompleto = contenido;
                const lineas = contenido.split('\n');
                for (const linea of lineas){
                    if (linea.includes('--- Equipos participantes ---')){
                        const m = linea.match(/<([^>]+)>/);
                        if (m){ this.botNick = m[1]; return; }
                    }
                }
            }

            procesarEquipos(contenido){
                const lineas = contenido.split('\n');
                let dentroEquipos = false;
                let equipoActual = null;
                for (const linea of lineas){
                    if (linea.includes('--- Equipos participantes ---')){ dentroEquipos = true; continue; }
                    if (linea.includes('--- DATOS RESETEADOS ---')){ dentroEquipos = false; break; }
                    if (dentroEquipos && this.botNick && linea.includes(`<${this.botNick}>`)){
                        if (!linea.includes('>>>')){
                            const equipos = ['FOGUETES','LIDERES','KAMIKAZES','ATIPIK@S','REPESCA@S','HARDBE@TS','TELERINEZ'];
                            for (const eq of equipos){
                                if (linea.includes(eq)){ equipoActual = eq; this.equipos[equipoActual] = []; break; }
                            }
                        } else if (linea.includes('>>>') && equipoActual){
                            const m = linea.match(/>>>\s*(.+)/);
                            if (m){
                                const jugadores = m[1].trim().split(/\s+/);
                                this.equipos[equipoActual] = jugadores;
                                jugadores.forEach(j => { this.jugadorEquipo[j] = equipoActual; });
                            }
                        }
                    }
                }
                this.detectarJugadoresActivosEnTodoElLog();
            }

            detectarJugadoresActivosEnTodoElLog(){
                const totalJugadores = Object.keys(this.jugadorEquipo).length;
                const lineas = this.contenidoCompleto.split('\n');
                for (const linea of lineas){
                    if (this.jugadoresActivos.size === totalJugadores) break;
                    const m = linea.match(/<([^>]+)>/);
                    if (!m) continue;
                    const nick = m[1];
                    if (nick === this.botNick ||
                        linea.includes('--- Equipos participantes ---') ||
                        linea.includes('>>>') ||
                        linea.includes('--- DATOS RESETEADOS ---') ||
                        linea.includes('Base Datos Preguntas:') ||
                        linea.includes('Pregunta:')
                    ){ continue; }
                    for (const jugadorRegistrado in this.jugadorEquipo){
                        if (nick.toLowerCase() === jugadorRegistrado.toLowerCase() && !this.jugadoresActivos.has(jugadorRegistrado)){
                            this.jugadoresActivos.add(jugadorRegistrado);
                            break;
                        }
                    }
                }
            }

            // NUEVO: inserta "DATO EXTRA PARA EL CRONISTA" al cierre de cada pregunta si marca r√©cord
            anotarDatosEnLinea(contenido){
                const lineas = contenido.split('\n');
                let currentQ = null;
                let startTime = null;
                let firstHitTime = null;
                let aciertosPorEquipoQ = {};
                let maxDificultad = { tiempo: -1, pregunta: null };
                let maxBrecha = { brecha: -1, pregunta: null, ganador: null };

                const isBotLine = (linea) => this.botNick && linea.includes(`<${this.botNick}>`);
                const tsOf = (linea) => { const m = linea.match(/^(\d{2}:\d{2}:\d{2})/); return m ? m[1] : null; };

                const diffSeconds = (inicio, fin) => {
                    const [h1,m1,s1] = inicio.split(':').map(Number);
                    const [h2,m2,s2] = fin.split(':').map(Number);
                    let a = h1*3600+m1*60+s1, b = h2*3600+m2*60+s2;
                    let d = b-a; if (d<0) d += 86400; return d;
                };

                const iniciarPregunta = (num, ts) => {
                    currentQ = num;
                    startTime = ts || null;
                    firstHitTime = null;
                    aciertosPorEquipoQ = {};
                    Object.keys(this.equipos).forEach(eq => aciertosPorEquipoQ[eq]=0);
                };

                const cerrarPreguntaYAnotar = (idxLinea) => {
                    if (currentQ==null) return [];
                    const inserciones = [];
                    // Calcular dificultad (tiempo hasta primer acierto)
                    let nuevoRecordDificultad = false;
                    if (startTime && firstHitTime){
                        const t = diffSeconds(startTime, firstHitTime);
                        if (t > maxDificultad.tiempo){
                            maxDificultad = { tiempo: t, pregunta: currentQ };
                            nuevoRecordDificultad = true;
                        }
                    }
                    // Calcular brecha
                    const valores = Object.values(aciertosPorEquipoQ);
                    let nuevoRecordBrecha = false;
                    if (valores.length){
                        const max = Math.max(...valores);
                        const min = Math.min(...valores);
                        const brecha = max - min;
                        if (brecha > maxBrecha.brecha && max > 0){
                            // ganador: equipo con m√°s aciertos (si empate, el primero por orden)
                            const ganador = Object.entries(aciertosPorEquipoQ).sort((a,b)=>b[1]-a[1])[0][0];
                            maxBrecha = { brecha, pregunta: currentQ, ganador };
                            nuevoRecordBrecha = true;
                        }
                    }
                    // Insertar textos justo despu√©s de "La buena / Las buenas"
                    if (nuevoRecordDificultad){
                        inserciones.push('*** DATO EXTRA PARA EL CRONISTA ***');
                        inserciones.push(`üê¢ Pregunta con mayor dificultad de la partida: P${currentQ}. El bot no dio el primer acertante hasta pasados ${maxDificultad.tiempo} segundos.`);
                    }
                    if (nuevoRecordBrecha){
                        inserciones.push('*** DATO EXTRA PARA EL CRONISTA ***');
                        inserciones.push(`üìà Mayor brecha detectada hasta ahora: P${currentQ}. ${maxBrecha.ganador} +${maxBrecha.brecha} frente a sus rivales en esta pregunta.`);
                    }
                    // reset por si acaso (la siguiente pregunta reinicia)
                    currentQ = null; startTime = null; firstHitTime = null; aciertosPorEquipoQ = {};
                    return inserciones;
                };

                const nuevasLineas = [];
                for (let i=0; i<lineas.length; i++){
                    const linea = lineas[i];
                    // Inicio de pregunta
                    const mInicio = linea.match(/^(\d{2}:\d{2}:\d{2}).*Pregunta:\s*(\d+)\s*\/\s*\d+.*Base\s*Datos\s*Preguntas:/i);
                    if (mInicio){
                        iniciarPregunta(parseInt(mInicio[2],10), mInicio[1]);
                        nuevasLineas.push(linea);
                        continue;
                    }

                    // Aciertos (para primer acierto y conteo por equipo)
                    if (isBotLine(linea) && currentQ!=null){
                        const mScratch = linea.match(/>>>(\S+)\s+scratchea/i);
                        const mAce     = linea.match(/>>>(\S+)\s+acea/i);
                        const mAcierto = linea.match(/>>>(\S+)\s+a\s+\d{2}''\d{2}/i);
                        let nick = null;
                        if (mScratch) nick = mScratch[1];
                        else if (mAce) nick = mAce[1];
                        else if (mAcierto) nick = mAcierto[1];

                        if (nick){
                            if (!firstHitTime){
                                const ts = tsOf(linea);
                                if (ts) firstHitTime = ts;
                            }
                            const eq = this.jugadorEquipo[nick];
                            if (eq && aciertosPorEquipoQ[eq] !== undefined){
                                aciertosPorEquipoQ[eq] += 1;
                            }
                        }

                        // Fin de pregunta (La buena / Las buenas)
                        if (/La buena:/i.test(linea) || /Las buenas:/i.test(linea)){
                            nuevasLineas.push(linea);
                            const inserciones = cerrarPreguntaYAnotar(i);
                            if (inserciones.length){
                                inserciones.forEach(txt => nuevasLineas.push(txt));
                            }
                            continue;
                        }
                    }

                    nuevasLineas.push(linea);
                }
                return nuevasLineas.join('\n');
            }

            contarPuntosAcumulativos(contenidoHastaAqui){
                const puntosPorJugador = {};
                const puntosEquipo = {};
                const palosPorJugador = {};
                const acesPorJugador = {};
                const scratchesPorJugador = {};
                const tiemposPorPregunta = {};
                const aciertosEquipoPorPregunta = {};

                for (const jugador in this.jugadorEquipo){
                    puntosPorJugador[jugador]=0; palosPorJugador[jugador]=0; acesPorJugador[jugador]=0; scratchesPorJugador[jugador]=0;
                }
                for (const equipo in this.equipos){ puntosEquipo[equipo]=0; }

                const lineas = contenidoHastaAqui.split('\n');
                let preguntaActual = null;

                for (const linea of lineas){
                    const mQ = linea.match(/^(\d{2}:\d{2}:\d{2}).*Pregunta:\s*(\d+)\s*\/\s*\d+.*Base\s*Datos\s*Preguntas:/i);
                    if (mQ){
                        preguntaActual = parseInt(mQ[2],10);
                        tiemposPorPregunta[preguntaActual] = { inicio: mQ[1], primerAcierto: null };
                        aciertosEquipoPorPregunta[preguntaActual] = {};
                        for (const eq in this.equipos){ aciertosEquipoPorPregunta[preguntaActual][eq]=0; }
                    }
                    if (!this.botNick || !linea.includes(`<${this.botNick}>`)) continue;

                    const mScratch = linea.match(/>>>(\S+)\s+scratchea/i);
                    const mAce     = linea.match(/>>>(\S+)\s+acea/i);
                    const mAcierto = linea.match(/>>>(\S+)\s+a\s+\d{2}''\d{2}/i);
                    const mPalo    = linea.match(/primer@?\s+sin\s+puntos:.*?>>>(\S+)/i);

                    let jugador = null;
                    if (mScratch || mAce || mAcierto){
                        jugador = (mScratch && mScratch[1]) || (mAce && mAce[1]) || (mAcierto && mAcierto[1]);
                        if (puntosPorJugador[jugador] !== undefined){
                            puntosPorJugador[jugador]++;
                            if (mScratch) scratchesPorJugador[jugador]++;
                            if (mAce){ acesPorJugador[jugador]++; scratchesPorJugador[jugador]++; }
                            const eq = this.jugadorEquipo[jugador];
                            if (eq){ puntosEquipo[eq]++; if (preguntaActual && aciertosEquipoPorPregunta[preguntaActual]) aciertosEquipoPorPregunta[preguntaActual][eq]++; }
                            if (preguntaActual && tiemposPorPregunta[preguntaActual] && !tiemposPorPregunta[preguntaActual].primerAcierto){
                                const mt = linea.match(/^(\d{2}:\d{2}:\d{2})/);
                                if (mt) tiemposPorPregunta[preguntaActual].primerAcierto = mt[1];
                            }
                        }
                    } else if (mPalo){
                        jugador = mPalo[1];
                        if (palosPorJugador[jugador] !== undefined) palosPorJugador[jugador]++;
                    }
                }

                return { puntosPorJugador, puntosEquipo, palosPorJugador, acesPorJugador, scratchesPorJugador, tiemposPorPregunta, aciertosEquipoPorPregunta };
            }

            obtenerEstadisticasEquipos(){
                const statsEquipos = {};
                for (const equipo in this.equipos){
                    const jugadoresEquipo = this.equipos[equipo];
                    const ausentes = jugadoresEquipo.filter(j => !this.jugadoresActivos.has(j));
                    const presentes = jugadoresEquipo.filter(j => this.jugadoresActivos.has(j));
                    statsEquipos[equipo] = { total: jugadoresEquipo.length, presentes: presentes.length, ausentes: ausentes.length, listaAusentes: ausentes };
                }
                return statsEquipos;
            }

            calcularDiferenciaTiempo(inicio, fin){
                const [h1,m1,s1] = inicio.split(':').map(Number);
                const [h2,m2,s2] = fin.split(':').map(Number);
                const t1 = h1*3600+m1*60+s1, t2 = h2*3600+m2*60+s2;
                let d = t2 - t1; if (d<0) d += 86400; return d;
            }

            generarResumen(contenidoHastaAqui, esPrimera, esUltima){
                let extras = [];
                const { puntosPorJugador, puntosEquipo, palosPorJugador, acesPorJugador, scratchesPorJugador, tiemposPorPregunta, aciertosEquipoPorPregunta } = this.contarPuntosAcumulativos(contenidoHastaAqui);

                extras.push('\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                extras.push('           üìä DATOS EXTRA DEL CORTE');
                extras.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                if (esPrimera){
                    extras.push('üèÜ EQUIPOS PARTICIPANTES:');
                    const statsEquipos = this.obtenerEstadisticasEquipos();
                    for (const equipo in this.equipos){
                        const stats = statsEquipos[equipo];
                        // üîÅ Ajuste: mostrar TOTAL/10 en plantilla
                        extras.push(`${equipo}: ${this.equipos[equipo].join(', ')} (${stats.total}/10 en plantilla)`);
                    }

                    extras.push('\n‚ö†Ô∏è AUSENCIAS POR EQUIPO:');
                    let hayAusencias = false;
                    for (const equipo in statsEquipos){
                        const stats = statsEquipos[equipo];
                        if (stats.ausentes > 0){
                            extras.push(`${equipo}: ${stats.listaAusentes.join(', ')} (${stats.ausentes} ausencias)`);
                            hayAusencias = true;
                        }
                    }
                    if (!hayAusencias) extras.push('No hay ausencias - todos los jugadores participan');

                    extras.push('\nüìã JUGADORES DISPONIBLES:');
                    const equiposDisponibles = [];
                    for (const equipo in statsEquipos){
                        const stats = statsEquipos[equipo];
                        equiposDisponibles.push(`${stats.presentes} ${equipo}`);
                    }
                    extras.push(equiposDisponibles.join(' vs '));
                    extras.push('');
                }

                const tituloMarcador = esUltima ? 'üèÅ MARCADOR FINAL:' : 'üìà MARCADOR EN EL CORTE:';
                extras.push(tituloMarcador);
                for (const equipo in puntosEquipo){ extras.push(`${equipo}: ${puntosEquipo[equipo]} puntos`); }

                if (!esUltima){
                    extras.push('\n‚≠ê LUCHA POR EL MVP:');
                    const top = Object.entries(puntosPorJugador).filter(([j,p])=>p>0).sort((a,b)=>b[1]-a[1]).slice(0,4);
                    if (top.length>0){
                        top.forEach(([j,p],i)=>{
                            const em = i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':'üèÖ';
                            extras.push(`${em} ${j}: ${p} puntos`);
                        });
                    } else extras.push('A√∫n no hay puntuaciones registradas');
                }

                if (esUltima && Object.keys(tiemposPorPregunta).length>0){
                    let qDif = null, tMax = 0;
                    for (const [q, t] of Object.entries(tiemposPorPregunta)){
                        if (t.inicio && t.primerAcierto){
                            const d = this.calcularDiferenciaTiempo(t.inicio, t.primerAcierto);
                            if (d > tMax){ tMax = d; qDif = parseInt(q,10); }
                        }
                    }
                    let qBrecha = null, brechaMax = 0, eqGan = null;
                    for (const [q, aciertos] of Object.entries(aciertosEquipoPorPregunta)){
                        const vals = Object.values(aciertos);
                        const max = Math.max(...vals), min = Math.min(...vals);
                        const b = max - min;
                        if (b > brechaMax && max > 0){
                            brechaMax = b; qBrecha = parseInt(q,10);
                            eqGan = Object.entries(aciertos).sort((a,b)=>b[1]-a[1])[0][0];
                        }
                    }
                    extras.push('\nüìä ESTAD√çSTICAS DE PREGUNTAS:');
                    if (qDif) extras.push(`üê¢ Pregunta con mayor dificultad: P${qDif} (el bot no dio el primer acertante hasta pasados ${tMax} segundos)`);
                    if (qBrecha) extras.push(`üìà Mayor brecha: P${qBrecha} (${eqGan} +${brechaMax})`);
                }

                if (esUltima){
                    extras.push('\nü•á CLASIFICACI√ìN INDIVIDUAL FINAL:');
                    const jugadoresOrden = Object.entries(puntosPorJugador).filter(([j,p])=>p>0).sort((a,b)=>b[1]-a[1]);
                    jugadoresOrden.forEach(([j,p])=>{
                        const palos = palosPorJugador[j]||0, aces = acesPorJugador[j]||0, scratches = scratchesPorJugador[j]||0;
                        const detalles = [`${p} puntos`];
                        if (scratches>0) detalles.push(`${scratches} scratches`);
                        if (aces>0) detalles.push(`${aces} aces`);
                        if (palos>0) detalles.push(`${palos} palos`);
                        extras.push(`${j}: ${detalles.join(', ')}`);
                    });

                    extras.push('\nüèÜ CLASIFICACI√ìN POR EQUIPOS FINAL:');
                    const equiposStats = {};
                    for (const eq in this.equipos){ equiposStats[eq] = { puntos: puntosEquipo[eq]||0, scratches:0, aces:0, palos:0 }; }
                    for (const j in this.jugadorEquipo){
                        const eq = this.jugadorEquipo[j];
                        if (equiposStats[eq]){
                            equiposStats[eq].scratches += scratchesPorJugador[j]||0;
                            equiposStats[eq].aces      += acesPorJugador[j]||0;
                            equiposStats[eq].palos     += palosPorJugador[j]||0;
                        }
                    }
                    const orden = Object.entries(equiposStats).sort((a,b)=>b[1].puntos-a[1].puntos);
                    orden.forEach(([eq,stats])=>{
                        const detalles = [`${stats.puntos} puntos`];
                        if (stats.scratches>0) detalles.push(`${stats.scratches} scratches`);
                        if (stats.aces>0) detalles.push(`${stats.aces} aces`);
                        if (stats.palos>0) detalles.push(`${stats.palos} palos`);
                        extras.push(`${eq}: ${detalles.join(', ')}`);
                    });
                }

                extras.push('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                return extras.join('\n');
            }
        }

        function limpiarLinea(linea){
            return linea
                .replace(/\x03\d{1,2}(?:,\d{1,2})?/g, "")
                .replace(/\x02/g, "").replace(/\x1D/g, "").replace(/\x1F/g, "").replace(/\x0F/g, "").replace(/\x7F/g, "")
                .replace(/\b\d{1,2},\d{1,2}\b/g, "")
                .replace(/\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])/g, "")
                .replace(/\s{2,}/g, " ")
                .replace(/^[:\?]\s*/, "")
                .trim();
        }
        function limpiarArchivo(contenido){ return contenido.split("\n").map(limpiarLinea).join("\n"); }
        function encontrarPosicionesPreguntas(contenido){
            const lineas = contenido.split("\n"); const posiciones = [];
            lineas.forEach((linea,i)=>{ if (/Pregunta:\s*\d+\s*\/\s*\d+.*Base\s*Datos\s*Preguntas:/i.test(linea)) posiciones.push(i); });
            return posiciones;
        }
        function dividirArchivo(contenido, numPartes=4){
            const lineas = contenido.split("\n");
            const posiciones = encontrarPosicionesPreguntas(contenido);
            if (posiciones.length===0) throw new Error("No se encontraron preguntas en el archivo");
            const total = lineas.length, porParte = Math.floor(total/numPartes), cortes=[];
            let ultimo=0;
            for (let i=1;i<numPartes;i++){
                const objetivo = i*porParte;
                let mejor = ultimo;
                for (const pos of posiciones){ if (pos<=objetivo && pos>ultimo) mejor=pos; }
                if (mejor>ultimo){ cortes.push(mejor); ultimo=mejor; }
            }
            const partes=[]; let inicio=0; const finales = cortes.concat([total]);
            finales.forEach((fin,idx)=>{
                const fragmento = lineas.slice(inicio,fin).join("\n");
                partes.push({ nombre:`parte_${String(idx+1).padStart(2,'0')}.txt`, contenido: fragmento, lineas: fin-inicio });
                inicio=fin;
            });
            return partes;
        }

        function handleFile(file){
            if (!file.name.match(/\.(txt|log)$/i)){ showMessage('Por favor selecciona un archivo .txt o .log','error'); return; }
            selectedFile = file;
            uploadText.textContent = `üìé ${file.name}`;
            uploadArea.classList.add('file-selected');
            processBtn.style.display = 'block';
            showMessage('Archivo cargado correctamente: ' + file.name, 'success');
        }

        function processLog(){
            if (!selectedFile){ showMessage("Selecciona un archivo primero",'error'); return; }
            const numPartes = parseInt(document.getElementById('numPartes').value)||4;
            const cleanIRC = document.getElementById('cleanIRC').checked;
            const addExtras = document.getElementById('addExtras').checked;
            showMessage('Procesando archivo...','success');

            const reader = new FileReader();
            reader.onload = (e)=>{
                try{
                    let contenido = e.target.result;
                    if (cleanIRC) contenido = limpiarArchivo(contenido);

                    let analizador = null;
                    if (addExtras){
                        analizador = new AnalizadorPartida();
                        analizador.identificarBot(contenido);
                        analizador.procesarEquipos(contenido);
                        // üîÅ NUEVO: insertar notas inline justo al cierre de cada pregunta si hay r√©cord
                        contenido = analizador.anotarDatosEnLinea(contenido);
                    }

                    const partes = dividirArchivo(contenido, numPartes);

                    if (addExtras && analizador){
                        let acumulado = '';
                        partes.forEach((parte, idx)=>{
                            acumulado += parte.contenido;
                            const esPrimera = idx===0, esUltima = idx===partes.length-1;
                            const extras = analizador.generarResumen(acumulado, esPrimera, esUltima);
                            parte.contenido += extras;
                        });
                    }

                    mostrarResultados(partes, numPartes);
                }catch(err){ showMessage("Error: "+err.message,'error'); }
            };
            reader.onerror = ()=> showMessage('Error al leer el archivo','error');
            reader.readAsText(selectedFile,'utf-8');
        }

        function mostrarResultados(partes, numPartes){
            results.innerHTML = `<h3>üì¶ Archivos Generados (${numPartes} partes)</h3>`;
            partes.forEach(parte=>{
                const fileItem = document.createElement('div'); fileItem.className='file-item';
                const info = document.createElement('div'); info.innerHTML = `<strong>${parte.nombre}</strong><br>${parte.lineas} l√≠neas | ${formatFileSize(parte.contenido.length)}`;
                const downloadBtn = document.createElement('button'); downloadBtn.className='download-btn'; downloadBtn.textContent='Descargar';
                downloadBtn.onclick = ()=> descargarParte(parte.nombre, parte.contenido);
                fileItem.appendChild(info); fileItem.appendChild(downloadBtn); results.appendChild(fileItem);
            });
            if (partes.length>1){
                const btnZip = document.createElement("button"); btnZip.className="button success"; btnZip.textContent="üì¶ Descargar todas en ZIP";
                btnZip.onclick = ()=> descargarZip(partes); results.appendChild(btnZip);
            }
            results.classList.add('show');
            showMessage(`Log procesado correctamente en ${numPartes} partes`,'success');
        }

        function descargarParte(nombre, contenido){
            const blob = new Blob([contenido], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a"); a.href=url; a.download=nombre; a.click();
            URL.revokeObjectURL(url);
        }
        async function descargarZip(partes){
            try{
                showMessage('Generando archivo ZIP...','success');
                const zip = new JSZip();
                partes.forEach(parte=> zip.file(parte.nombre, parte.contenido));
                const blob = await zip.generateAsync({ type:"blob" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a"); a.href=url; a.download="partes_trivial.zip"; a.click();
                URL.revokeObjectURL(url);
                showMessage('ZIP descargado correctamente','success');
            }catch(e){ showMessage('Error al generar el archivo ZIP','error'); }
        }
        function formatFileSize(bytes){ if (bytes<1024) return bytes+' bytes'; else if (bytes<1048576) return Math.round(bytes/1024)+' KB'; else return Math.round(bytes/1048576)+' MB'; }
        function showMessage(msg,type){
            const div = document.createElement('div'); div.className=`message ${type}`; div.textContent=msg; messages.appendChild(div);
            setTimeout(()=>{ if (div.parentNode) div.parentNode.removeChild(div); }, 5000);
        }
    </script>
</body>
</html>
