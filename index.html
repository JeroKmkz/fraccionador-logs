<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Fraccionador de Logs - Trivial IRC</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;display:flex;justify-content:center;align-items:center;padding:20px}
    .container{background:#fff;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.3);max-width:700px;width:100%;padding:40px;animation:slideIn .5s ease-out}
    @keyframes slideIn{from{opacity:0;transform:translateY(30px)}to{opacity:1;transform:translateY(0)}}
    h1{text-align:center;color:#333;margin-bottom:10px;font-size:2em}
    .subtitle{text-align:center;color:#666;margin-bottom:30px;font-size:.9em}
    .upload-area{border:3px dashed #ddd;padding:40px;text-align:center;margin-bottom:30px;border-radius:15px;background:#fafafa;cursor:pointer;transition:.3s}
    .upload-area:hover,.upload-area.dragover{border-color:#667eea;background:#f0f0ff;transform:scale(1.02)}
    .upload-icon{font-size:3em;margin-bottom:10px;color:#667eea}
    .options{margin-bottom:30px;padding:20px;background:#f8f9fa;border-radius:10px}
    .option-group{margin-bottom:20px}
    .option-label{display:block;color:#555;margin-bottom:8px;font-weight:500}
    .option-input{width:100%;padding:10px;border:2px solid #ddd;border-radius:8px;font-size:1em}
    .checkbox-group{display:flex;align-items:center;gap:10px}
    .checkbox-group input{width:20px;height:20px;cursor:pointer}
    .button{background:#007bff;color:#fff;padding:15px 25px;border:none;border-radius:8px;cursor:pointer;font-size:16px;font-weight:bold;width:100%;margin:10px 0;transition:.3s}
    .button:hover{background:#0056b3}
    .button:disabled{background:#ccc;cursor:not-allowed}
    .button.success{background:#28a745}
    .button.success:hover{background:#218838}
    .results{margin-top:30px;display:none}
    .results.show{display:block}
    .file-item{background:#f8f9fa;border:1px solid #ddd;border-radius:8px;padding:15px;margin-bottom:10px;display:flex;justify-content:space-between;align-items:center}
    .download-btn{padding:8px 20px;background:#667eea;color:#fff;border:none;border-radius:6px;cursor:pointer;transition:.3s}
    .download-btn:hover{background:#5a67d8}
    .message{padding:15px;margin:10px 0;border-radius:8px}
    .success{background:#d4edda;color:#155724;border:1px solid #c3e6cb}
    .error{background:#f8d7da;color:#721c24;border:1px solid #f5c6cb}
    .extras-section{background:#f0f4ff;border:2px solid #667eea;border-radius:10px;padding:15px;margin-bottom:20px}
    .extras-title{color:#667eea;font-weight:bold;margin-bottom:10px}
    .file-selected{background:#e8f5e9;border-color:#4caf50}
    small{display:block;color:#6b7280;margin-top:6px}
  </style>
</head>
<body>
  <div class="container">
    <h1>üìÇ Fraccionador de Logs IRC</h1>
    <p class="subtitle">Limpia y divide tus logs de partidas con an√°lisis estad√≠stico</p>

    <div class="upload-area" id="uploadArea">
      <div class="upload-icon">üìÅ</div>
      <div id="uploadText">Arrastra tu archivo aqu√≠ o haz clic para seleccionar</div>
      <input type="file" id="fileInput" accept=".txt,.log" style="display:none"/>
    </div>

    <div class="options">
      <div class="option-group">
        <label class="option-label" for="numPartes">N√∫mero de partes:</label>
        <input type="number" id="numPartes" class="option-input" min="2" max="20" value="4"/>
      </div>

      <div class="option-group">
        <div class="checkbox-group">
          <input type="checkbox" id="cleanIRC" checked/>
          <label for="cleanIRC">Limpiar c√≥digos IRC</label>
        </div>
        <small>Elimina c√≥digos de color/formato IRC. Recomendado para an√°lisis robusto.</small>
      </div>

      <div class="option-group">
        <div class="checkbox-group">
          <input type="checkbox" id="cleanMax" checked/>
          <label for="cleanMax">Limpieza m√°xima (compactar para cr√≥nica)</label>
        </div>
        <small>Quita timestamps, marcador intermedio, ‚ÄúRespuestas acertadas‚Äù, ‚ÄúMandada por‚Ä¶‚Äù, ‚ÄúBase Datos Preguntas: ‚Ä¶‚Äù, y compacta ‚Äú&lt;nick&gt;‚Äù a ‚Äúnick>‚Äù.</small>
      </div>

      <div class="extras-section">
        <div class="extras-title">üìä An√°lisis Extra (para Cronista)</div>
        <div class="checkbox-group">
          <input type="checkbox" id="addExtras"/>
          <label for="addExtras">A√±adir estad√≠sticas y an√°lisis en cada corte</label>
        </div>
      </div>
    </div>

    <button class="button" id="processBtn" style="display:none">Procesar Archivo</button>
    <div id="messages"></div>
    <div id="results" class="results"></div>
  </div>

  <script>
    let selectedFile=null;
    const uploadArea=document.getElementById('uploadArea');
    const fileInput=document.getElementById('fileInput');
    const uploadText=document.getElementById('uploadText');
    const processBtn=document.getElementById('processBtn');
    const messages=document.getElementById('messages');
    const results=document.getElementById('results');

    uploadArea.onclick=()=>fileInput.click();
    uploadArea.ondragover=e=>{e.preventDefault();uploadArea.classList.add('dragover');};
    uploadArea.ondragleave=e=>{e.preventDefault();uploadArea.classList.remove('dragover');};
    uploadArea.ondrop=e=>{
      e.preventDefault();uploadArea.classList.remove('dragover');
      const files=e.dataTransfer.files; if(files.length>0) handleFile(files[0]);
    };
    fileInput.onchange=e=>{ if(e.target.files.length>0) handleFile(e.target.files[0]); };
    processBtn.onclick=()=>processLog();

    // -------- Normalizaci√≥n "s√≥lo para detectar", sin alterar el contenido real --------
    function stripIrcCodes(s){
      if(!s) return s;
      return s
        .replace(/\x03\d{1,2}(?:,\d{1,2})?/g,"") // mIRC colors
        .replace(/\x02/g,"") // bold
        .replace(/\x1D/g,"") // italics
        .replace(/\x1F/g,"") // underline
        .replace(/\x0F/g,"") // reset
        .replace(/\x7F/g,"") // del
        .replace(/\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])/g,""); // ANSI
    }
    function plain(line){ return stripIrcCodes(line); }

    // -------- Limpieza m√°xima (compactar para cr√≥nica) --------
    function limpiarArchivoMax(contenido){
      const lineas = contenido.split('\n');
      const out = [];

      // Estados de salto de bloques
      let skipScore = false;       // bloque "Puntuaci√≥n de equipos"
      let skipAciertos = false;    // bloque "Respuestas acertadas"

      // Patrones de l√≠neas-r√°nking (con o sin cabecera)
      const reLineaScore = /^\s*(?:<[^>]+>\s*)?\d+¬∫?\s+\d+\s+\S+/i; // "<nick> 1¬∫ 121 LIDERES"
      const reLineaAciertos = /^\s*(?:<[^>]+>\s*)?\d+\s+[¬∑\w\-]+/i; // "<nick> 9 ¬∑JERONIMO‚Äì"

      for(let i=0;i<lineas.length;i++){
        let line = lineas[i];
        const pl = plain(line);

        // ¬øsaltando bloque "Puntuaci√≥n de equipos"?
        if (skipScore) {
          if (reLineaScore.test(pl)) continue;
          skipScore = false;
        }
        // ¬øsaltando bloque "Respuestas acertadas"?
        if (skipAciertos) {
          if (reLineaAciertos.test(pl)) continue;
          skipAciertos = false;
        }

        // Inicios de bloques a omitir
        if (/Puntuaci√≥n\s+de\s+equipos/i.test(pl)) { skipScore = true; continue; }
        if (/Respuestas\s+acertadas/i.test(pl))    { skipAciertos = true; continue; }

        // Tambi√©n eliminar r√°nkings sueltos aunque no haya cabecera
        if (reLineaScore.test(pl) || reLineaAciertos.test(pl)) continue;

        // Quitar 'Mandada por: ...' manteniendo "La buena/Las buenas"
        if (/La(s)?\s+buena(s)?:/i.test(pl)) {
          line = line.replace(/(\bLa(?:s)?\s+buena(?:s)?:[^]*?)(\s+Mandada\s+por:.*)$/i, "$1");
        }

        // Quitar el sufijo "Base Datos Preguntas: ..." (ruido en cada pregunta)
        line = line.replace(/Base\s*Datos\s*Preguntas:.*$/i, "");

        // Quitar timestamps al inicio (ej. 23:00:12''257  o  23:00:12 )
        line = line.replace(/^\d{2}:\d{2}:\d{2}(?:''\d+)?\s*/, "");

        // Quitar el "<" inicial del nick, pero conservar el ">" como separador
        line = line.replace(/^<([^>]+)>/, "$1>");

        // Compactar aciertos: ">>>NICK ..." -> ">>NICK ..."
        line = line.replace(/>>>/g, ">>");

        // Quitar l√≠neas cortas de relleno tipo "xd", "jaja", "jeje", "lol" (conservador)
        const short = pl.trim().toLowerCase();
        if (short.length <= 6 && /^(x+d+|j+a+ja+|j+e+je+|lol+|lmao+|uy+|uff+)$/.test(short)) {
          continue;
        }

        // Limpiezas menores
        line = line.replace(/\s{2,}/g, " ").trimEnd();
        if (line.trim() === "") continue;

        out.push(line);
      }
      return out.join('\n');
    }

    // Helper: detecta l√≠neas del bot tanto "<bot>" como "bot>"
    function isBotAuthorLine(line, botNick){
      if(!botNick) return false;
      const pl = plain(line);
      return pl.includes(`<${botNick}>`) || new RegExp(`^${botNick}>\\s*`).test(pl);
    }

    class AnalizadorPartida{
      constructor(){
        this.equipos={};
        this.jugadorEquipo={};
        this.botNick=null;
        this.jugadoresActivos=new Set();
        this.contenidoCompleto='';
        this.totalPreguntas=null; // total detectado (denominador)
      }

      identificarBot(contenido){
        this.contenidoCompleto=contenido;
        for(const linea of contenido.split('\n')){
          const pl = plain(linea);
          if(pl.includes('--- Equipos participantes ---')){
            const m=pl.match(/<([^>]+)>/); if(m){ this.botNick=m[1]; return; }
          }
        }
      }

      procesarEquipos(contenido){
        const lineas=contenido.split('\n');
        let dentro=false, equipoActual=null;
        for(const linea of lineas){
          const pl = plain(linea);
          if(pl.includes('--- Equipos participantes ---')){ dentro=true; continue; }
          if(pl.includes('--- DATOS RESETEADOS ---')){ dentro=false; break; }
          if(dentro && this.botNick && pl.includes(`<${this.botNick}>`)){
            if(!pl.includes('>>>')){
              const posibles=['FOGUETES','LIDERES','KAMIKAZES','ATIPIK@S','REPESCA@S','HARDBE@TS','TELERINEZ'];
              for(const eq of posibles){ if(pl.includes(eq)){ equipoActual=eq; this.equipos[eq]=[]; break; } }
            }else if(equipoActual){
              const m=pl.match(/>>>\s*(.+)/);
              if(m){
                const jugadores=m[1].trim().split(/\s+/);
                this.equipos[equipoActual]=jugadores;
                jugadores.forEach(j=>{ this.jugadorEquipo[j]=equipoActual; });
              }
            }
          }
        }
        this.detectarJugadoresActivosEnTodoElLog();
      }

      detectarJugadoresActivosEnTodoElLog(){
        const total=Object.keys(this.jugadorEquipo).length;
        for(const linea of this.contenidoCompleto.split('\n')){
          if(this.jugadoresActivos.size===total) break;
          const pl = plain(linea);
          const m=pl.match(/<([^>]+)>/); if(!m) continue;
          const nick=m[1];
          if(nick===this.botNick ||
             pl.includes('--- Equipos participantes ---') ||
             pl.includes('>>>') ||
             pl.includes('--- DATOS RESETEADOS ---') ||
             pl.includes('Base Datos Preguntas:') ||
             pl.includes('Pregunta:')) continue;
          for(const jr in this.jugadorEquipo){
            if(nick.toLowerCase()===jr.toLowerCase() && !this.jugadoresActivos.has(jr)){
              this.jugadoresActivos.add(jr); break;
            }
          }
        }
      }

      // -------- PREAN√ÅLISIS GLOBAL (1¬™ pasada) --------
      precomputarRecordsGlobales(contenido){
        const lineas=contenido.split('\n');
        let currentQ=null, startTime=null, firstHitTime=null;
        let aciertosPorEquipoQ={};
        let jugadoresQueAcertaronEnQ=new Set();

        const streakActual={}; // jugador -> longitud
        let recordRachaCortada={len:0,jugador:null,qCorte:null};

        const tsOf = l => { const m=plain(l).match(/^(\d{2}:\d{2}:\d{2})/); return m?m[1]:null; };
        const diffSec = (a,b)=>{
          const [h1,m1,s1]=a.split(':').map(Number), [h2,m2,s2]=b.split(':').map(Number);
          let x=h1*3600+m1*60+s1, y=h2*3600+m2*60+s2; let d=y-x; if(d<0) d+=86400; return d;
        };

        let maxDificultad={tiempo:-1,q:null};

        // ‚Äúparcial‚Äù con m√∫ltiples ocurrencias y umbral +3
        let maxParcialVal=-1;
        let parcialesMaximos=[]; // [{q, ganador, brecha}]

        const iniciarPregunta=(num,ts,total=null)=>{
          currentQ=num; startTime=ts||null; firstHitTime=null;
          if(total){ this.totalPreguntas = Math.max(this.totalPreguntas||0, total); }
          aciertosPorEquipoQ={}; Object.keys(this.equipos).forEach(eq=>aciertosPorEquipoQ[eq]=0);
          jugadoresQueAcertaronEnQ=new Set();
        };

        const cerrarPregunta=()=>{
          // dificultad
          if(startTime && firstHitTime){
            const t=diffSec(startTime, firstHitTime);
            if(t>maxDificultad.tiempo) maxDificultad={tiempo:t,q:currentQ};
          }
          // parcial (posibles empates)
          const vals=Object.values(aciertosPorEquipoQ);
          if(vals.length){
            const max=Math.max(...vals), min=Math.min(...vals), b=max-min;
            if(max>0){
              if(b>maxParcialVal){
                maxParcialVal=b;
                const ganador=Object.entries(aciertosPorEquipoQ).sort((a,b)=>b[1]-a[1])[0][0];
                parcialesMaximos=[{q:currentQ, ganador, brecha:b}];
              }else if(b===maxParcialVal && b>=0){
                const ganador=Object.entries(aciertosPorEquipoQ).sort((a,b)=>b[1]-a[1])[0][0];
                parcialesMaximos.push({q:currentQ, ganador, brecha:b});
              }
            }
          }
          // rachas
          jugadoresQueAcertaronEnQ.forEach(j=>{ streakActual[j]=(streakActual[j]||0)+1; });
          for(const j in this.jugadorEquipo){
            if(!jugadoresQueAcertaronEnQ.has(j) && (streakActual[j]||0)>0){
              const len=streakActual[j];
              if(len>=8 && len>(recordRachaCortada.len||0)){
                recordRachaCortada={len, jugador:j, qCorte:currentQ};
              }
              streakActual[j]=0;
            }
          }
          currentQ=null; startTime=null; firstHitTime=null; aciertosPorEquipoQ={}; jugadoresQueAcertaronEnQ=new Set();
        };

        for(let i=0;i<lineas.length;i++){
          const linea=lineas[i];
          const pl = plain(linea);
          const mStart=pl.match(/^(\d{2}:\d{2}:\d{2}).*Pregunta:\s*(\d+)\s*\/\s*(\d+).*Base\s*Datos\s*Preguntas:/i);
          if(mStart){
            const qNum=parseInt(mStart[2],10);
            const total=parseInt(mStart[3],10);
            iniciarPregunta(qNum, mStart[1], total);
            continue;
          }

          if(isBotAuthorLine(linea, this.botNick) && currentQ!=null){
            const mScratch=pl.match(/>>>(\S+)\s+scratchea/i);
            const mAce    =pl.match(/>>>(\S+)\s+acea/i);
            const mAcierto=pl.match(/>>>(\S+)\s+a\s+\d{2}''\d{2}/i);
            let nick=null;
            if(mScratch) nick=mScratch[1];
            else if(mAce) nick=mAce[1];
            else if(mAcierto) nick=mAcierto[1];

            if(nick){
              if(!firstHitTime){ const ts=tsOf(linea); if(ts) firstHitTime=ts; }
              const eq=this.jugadorEquipo[nick];
              if(eq && eq in this.equipos){
                aciertosPorEquipoQ[eq]=(aciertosPorEquipoQ[eq]||0)+1;
              }
              jugadoresQueAcertaronEnQ.add(nick);
            }

            if(/La buena:/i.test(pl) || /Las buenas:/i.test(pl)){ cerrarPregunta(); }
          }
        }

        // Aplicar umbral m√≠nimo +3 para ‚Äúparcial‚Äù
        if(maxParcialVal < 3){ parcialesMaximos=[]; }

        this.recordsGlobales={
          dificultad:maxDificultad.tiempo>=0 ? maxDificultad : null,
          parciales:parcialesMaximos, // array de ocurrencias
          racha:recordRachaCortada.len>=8 ? recordRachaCortada : null
        };
      }

      // -------- 2¬™ pasada: inserci√≥n en preguntas con r√©cords globales + marcador sprint final --------
      anotarDatosEnLinea(contenido){
        if(!this.recordsGlobales) this.precomputarRecordsGlobales(contenido);

        const lineas=contenido.split('\n');
        let currentQ=null;
        const parcialesQs = new Set((this.recordsGlobales.parciales||[]).map(b=>b.q));

        // Puntuaci√≥n acumulada por equipo para ir anunciando marcadores
        const scoreEquipo = {}; Object.keys(this.equipos).forEach(eq=>scoreEquipo[eq]=0);

        const nuevas=[];
        for(let i=0;i<lineas.length;i++){
          const linea=lineas[i];
          const pl = plain(linea);
          const mStart=pl.match(/^\d{2}:\d{2}:\d{2}.*Pregunta:\s*(\d+)\s*\/\s*(\d+)/i);
          if(mStart){
            currentQ=parseInt(mStart[1],10);
            const total=parseInt(mStart[2],10);
            if(!this.totalPreguntas || total>this.totalPreguntas) this.totalPreguntas=total;
            nuevas.push(linea);
            continue;
          }

          // Contabilizar puntos en vivo para marcador sprint final
          if(isBotAuthorLine(linea, this.botNick)){
            const mScratch=pl.match(/>>>(\S+)\s+scratchea/i);
            const mAce    =pl.match(/>>>(\S+)\s+acea/i);
            const mAcierto=pl.match(/>>>(\S+)\s+a\s+\d{2}''\d{2}/i);
            const nick = (mScratch&&mScratch[1]) || (mAce&&mAce[1]) || (mAcierto&&mAcierto[1]) || null;
            if(nick){
              const eq=this.jugadorEquipo[nick];
              if(eq && (eq in scoreEquipo)) scoreEquipo[eq]+=1;
            }
          }

          nuevas.push(linea);

          // Cierre de pregunta ‚Üí insertar DATO EXTRA si toca
          if(isBotAuthorLine(linea, this.botNick) && currentQ!=null &&
             (/La buena:/i.test(pl) || /Las buenas:/i.test(pl))){

            // DIFICULTAD (√∫nica)
            if(this.recordsGlobales.dificultad &&
               this.recordsGlobales.dificultad.q === currentQ){
              nuevas.push('*** DATO EXTRA PARA EL CRONISTA ***');
              nuevas.push(`üê¢ Pregunta con mayor dificultad de la partida: P${currentQ}. El bot no dio el primer acertante hasta pasados ${this.recordsGlobales.dificultad.tiempo} segundos.`);
            }

            // PARCIAL (m√∫ltiples ocurrencias del r√©cord)
            if(parcialesQs.has(currentQ)){
              const ocurrencias = (this.recordsGlobales.parciales||[]).filter(b=>b.q===currentQ);
              ocurrencias.forEach(({ganador,brecha})=>{
                nuevas.push('*** DATO EXTRA PARA EL CRONISTA ***');
                nuevas.push(`üìà Parcial de la pregunta: P${currentQ}. ${ganador} +${brecha} frente a sus rivales en esta pregunta.`);
              });
            }

            // SPRINT FINAL: marcador si estamos en √∫ltimas 5 y diferencia ‚â§ 10
            if(this.totalPreguntas && currentQ >= this.totalPreguntas-4){
              const orden = Object.entries(scoreEquipo).sort((a,b)=>b[1]-a[1]);
              if(orden.length>=2){
                const diff = Math.abs(orden[0][1]-orden[1][1]);
                if(diff<=10){
                  const marcador = orden.map(([eq,pts])=>`${eq} ${pts}`).join(' | ');
                  nuevas.push('*** DATO EXTRA PARA EL CRONISTA ***');
                  nuevas.push(`‚è±Ô∏è Marcador tras P${currentQ}: ${marcador} (dif ${diff})`);
                }
              }
            }

            // RACHA (√∫nica)
            if(this.recordsGlobales.racha &&
               this.recordsGlobales.racha.qCorte === currentQ){
              const {len,jugador}=this.recordsGlobales.racha;
              nuevas.push('*** DATO EXTRA PARA EL CRONISTA ***');
              nuevas.push(`üî• Racha interrumpida: ${jugador} acumulaba ${len} preguntas seguidas con acierto y se cort√≥ en P${currentQ}.`);
            }

            currentQ=null;
          }
        }
        return nuevas.join('\n');
      }

      contarPuntosAcumulativos(contenidoHastaAqui){
        const puntosPorJugador={}, puntosEquipo={}, palosPorJugador={}, acesPorJugador={}, scratchesPorJugador={};
        for(const j in this.jugadorEquipo){ puntosPorJugador[j]=0; palosPorJugador[j]=0; acesPorJugador[j]=0; scratchesPorJugador[j]=0; }
        for(const e in this.equipos){ puntosEquipo[e]=0; }

        for(const linea of contenidoHastaAqui.split('\n')){
          const pl = plain(linea);
          if(!isBotAuthorLine(linea, this.botNick)) continue;

          const mScratch=pl.match(/>>>(\S+)\s+scratchea/i);
          const mAce    =pl.match(/>>>(\S+)\s+acea/i);
          const mAcierto=pl.match(/>>>(\S+)\s+a\s+\d{2}''\d{2}/i);
          const mPalo   =pl.match(/primer@?\s+sin\s+puntos:.*?>>>(\S+)/i);

          let jugador=null;
          if(mScratch || mAce || mAcierto){
            jugador=(mScratch&&mScratch[1])||(mAce&&mAce[1])||(mAcierto&&mAcierto[1]);
            if(puntosPorJugador[jugador]!==undefined){
              puntosPorJugador[jugador]++;
              if(mScratch) scratchesPorJugador[jugador]++;
              if(mAce){ acesPorJugador[jugador]++; scratchesPorJugador[jugador]++; }
              const eq=this.jugadorEquipo[jugador];
              if(eq){ puntosEquipo[eq]=(puntosEquipo[eq]||0)+1; }
            }
          }else if(mPalo){
            jugador=mPalo[1]; if(palosPorJugador[jugador]!==undefined) palosPorJugador[jugador]++;
          }
        }

        return { puntosPorJugador,puntosEquipo,palosPorJugador,scratchesPorJugador,acesPorJugador };
      }

      obtenerEstadisticasEquipos(){
        const stats={};
        for(const eq in this.equipos){
          const lista=this.equipos[eq];
          const aus=lista.filter(j=>!this.jugadoresActivos.has(j));
          const pre=lista.filter(j=>this.jugadoresActivos.has(j));
          stats[eq]={ total:lista.length, presentes:pre.length, ausentes:aus.length, listaAusentes:aus };
        }
        return stats;
      }

      generarResumen(contenidoHastaAqui, esPrimera, esUltima){
        let extras=[];
        const { puntosPorJugador,puntosEquipo,palosPorJugador,acesPorJugador,scratchesPorJugador } =
          this.contarPuntosAcumulativos(contenidoHastaAqui);

        extras.push('\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        extras.push('           üìä DATOS EXTRA DEL CORTE');
        extras.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

        if(esPrimera){
          extras.push('üèÜ EQUIPOS PARTICIPANTES:');
          const st=this.obtenerEstadisticasEquipos();
          for(const eq in this.equipos){
            const s=st[eq];
            extras.push(`${eq}: ${this.equipos[eq].join(', ')} (${s.total}/10 en plantilla)`);
          }
          extras.push('\n‚ö†Ô∏è AUSENCIAS POR EQUIPO:');
          let hay=false;
          for(const eq in st){
            if(st[eq].ausentes>0){ extras.push(`${eq}: ${st[eq].listaAusentes.join(', ')} (${st[eq].ausentes} ausencias)`); hay=true; }
          }
          if(!hay) extras.push('No hay ausencias - todos los jugadores participan');

          extras.push('\nüìã JUGADORES DISPONIBLES:');
          const disponibles=[]; for(const eq in st){ disponibles.push(`${st[eq].presentes} ${eq}`); }
          extras.push(disponibles.join(' vs '));
          extras.push('');
        }

        const titulo=esUltima?'üèÅ MARCADOR FINAL:':'üìà MARCADOR EN EL CORTE:';
        extras.push(titulo);
        for(const eq in puntosEquipo) extras.push(`${eq}: ${puntosEquipo[eq]||0} puntos`);

        if(!esUltima){
          extras.push('\n‚≠ê LUCHA POR EL MVP:');
          const top=Object.entries(puntosPorJugador).filter(([_,p])=>p>0).sort((a,b)=>b[1]-a[1]).slice(0,4);
          if(top.length){
            top.forEach(([j,p],i)=>{ const em=i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':'üèÖ'; extras.push(`${em} ${j}: ${p} puntos`); });
          }else extras.push('A√∫n no hay puntuaciones registradas');
        }

        // --- ESTAD√çSTICAS DE PREGUNTAS SOLO EN LA PARTE FINAL (recordsGlobales coherentes)
        if (esUltima && this.recordsGlobales) {
          const rg = this.recordsGlobales;
          extras.push('\nüìä ESTAD√çSTICAS DE PREGUNTAS:');

          if (rg.dificultad) {
            extras.push(
              `üê¢ Pregunta con mayor dificultad: P${rg.dificultad.q} ` +
              `(el bot no dio el primer acertante hasta pasados ${rg.dificultad.tiempo} segundos)`
            );
          }

          if (rg.parciales && rg.parciales.length) {
            const desc = rg.parciales
              .map(b => `P${b.q} (${b.ganador} +${b.brecha})`)
              .join(', ');
            extras.push(`üìà Parcial m√°s favorable: ${desc}`);
          }

          if (rg.racha) {
            extras.push(
              `üî• Racha interrumpida: ${rg.racha.jugador} ` +
              `llevaba ${rg.racha.len} seguidas y se cort√≥ en P${rg.racha.qCorte}`
            );
          }
        }

        if(esUltima){
          extras.push('\nü•á CLASIFICACI√ìN INDIVIDUAL FINAL:');
          Object.entries(puntosPorJugador).filter(([_,p])=>p>0).sort((a,b)=>b[1]-a[1]).forEach(([j,p])=>{
            const palos=palosPorJugador[j]||0, aces=acesPorJugador[j]||0, scratches=scratchesPorJugador[j]||0;
            const det=[`${p} puntos`];
            if(scratches>0) det.push(`${scratches} scratches`);
            if(aces>0) det.push(`${aces} aces`);
            if(palos>0) det.push(`${palos} palos`);
            extras.push(`${j}: ${det.join(', ')}`);
          });

          extras.push('\nüèÜ CLASIFICACI√ìN POR EQUIPOS FINAL:');
          const eStats={};
          for(const eq in this.equipos){ eStats[eq]={ puntos:puntosEquipo[eq]||0, scratches:0, aces:0, palos:0 }; }
          for(const j in this.jugadorEquipo){
            const eq=this.jugadorEquipo[j];
            if(eStats[eq]){
              eStats[eq].scratches += (scratchesPorJugador[j]||0);
              eStats[eq].aces      += (acesPorJugador[j]||0);
              eStats[eq].palos     += (palosPorJugador[j]||0);
            }
          }
          Object.entries(eStats).sort((a,b)=>b[1].puntos-a[1].puntos).forEach(([eq,s])=>{
            const det=[`${s.puntos} puntos`];
            if(s.scratches>0) det.push(`${s.scratches} scratches`);
            if(s.aces>0) det.push(`${s.aces} aces`);
            if(s.palos>0) det.push(`${s.palos} palos`);
            extras.push(`${eq}: ${det.join(', ')}`);
          });
        }

        extras.push('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
        return extras.join('\n');
      }
    }

    function limpiarLinea(linea){
      return linea
        .replace(/\x03\d{1,2}(?:,\d{1,2})?/g,"")
        .replace(/\x02/g,"").replace(/\x1D/g,"").replace(/\x1F/g,"").replace(/\x0F/g,"").replace(/\x7F/g,"")
        .replace(/\b\d{1,2},\d{1,2}\b/g,"")
        .replace(/\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])/g,"")
        .replace(/\s{2,}/g," ")
        .replace(/^[:\?]\s*/,"")
        .trim();
    }
    function limpiarArchivo(contenido){ return contenido.split("\n").map(limpiarLinea).join("\n"); }

    function encontrarPosicionesPreguntas(contenido){
      const pos=[]; contenido.split("\n").forEach((l,i)=>{
        if(/Pregunta:\s*\d+\s*\/\s*\d+/i.test(plain(l))) pos.push(i);
      });
      return pos;
    }

    function dividirArchivo(contenido,numPartes=4){
      const lineas=contenido.split("\n");
      const posiciones=encontrarPosicionesPreguntas(contenido);
      if(!posiciones.length) throw new Error("No se encontraron preguntas en el archivo");
      const total=lineas.length, porParte=Math.floor(total/numPartes), cortes=[]; let ultimo=0;
      for(let i=1;i<numPartes;i++){
        const objetivo=i*porParte; let mejor=ultimo;
        for(const p of posiciones){ if(p<=objetivo && p>ultimo) mejor=p; }
        if(mejor>ultimo){ cortes.push(mejor); ultimo=mejor; }
      }
      const partes=[]; let inicio=0; const finales=cortes.concat([total]);
      finales.forEach((fin,idx)=>{
        const fragmento=lineas.slice(inicio,fin).join("\n");
        partes.push({nombre:`parte_${String(idx+1).padStart(2,'0')}.txt`, contenido:fragmento, lineas:fin-inicio});
        inicio=fin;
      });
      return partes;
    }

    function handleFile(file){
      if(!file.name.match(/\.(txt|log)$/i)){ showMessage('Por favor selecciona un archivo .txt o .log','error'); return; }
      selectedFile=file; uploadText.textContent=`üìé ${file.name}`;
      uploadArea.classList.add('file-selected'); processBtn.style.display='block';
      showMessage('Archivo cargado correctamente: '+file.name,'success');
    }

    function processLog(){
      if(!selectedFile){ showMessage("Selecciona un archivo primero",'error'); return; }
      const numPartes=parseInt(document.getElementById('numPartes').value)||4;
      const cleanIRC=document.getElementById('cleanIRC').checked;
      const cleanMax=document.getElementById('cleanMax').checked;
      const addExtras=document.getElementById('addExtras').checked;
      showMessage('Procesando archivo...','success');

      const reader=new FileReader();
      reader.onload=(e)=>{
        try{
          const original = e.target.result;

          // Fuente para AN√ÅLISIS (con o sin limpieza IRC)
          let fuenteAnalisis = cleanIRC ? limpiarArchivo(original) : original;

          let analizador=null;
          let anotado = fuenteAnalisis;

          if(addExtras){
            analizador=new AnalizadorPartida();
            analizador.identificarBot(fuenteAnalisis);
            analizador.procesarEquipos(fuenteAnalisis);
            analizador.precomputarRecordsGlobales(fuenteAnalisis);
            anotado=analizador.anotarDatosEnLinea(fuenteAnalisis);
          }

          // Fuente para SALIDA: limpieza m√°xima opcional (sobre el anotado)
          let contenidoSalida = cleanMax ? limpiarArchivoMax(anotado) : anotado;

          const partes=dividirArchivo(contenidoSalida, numPartes);

          if(addExtras && analizador){
            let acumulado='';
            partes.forEach((parte,idx)=>{
              acumulado+=parte.contenido;
              const esPrimera=idx===0, esUltima=idx===partes.length-1;
              const extras=analizador.generarResumen(acumulado, esPrimera, esUltima);
              parte.contenido+=extras;
            });
          }

          mostrarResultados(partes,numPartes);
        }catch(err){ showMessage("Error: "+err.message,'error'); }
      };
      reader.onerror=()=>showMessage('Error al leer el archivo','error');
      reader.readAsText(selectedFile,'utf-8');
    }

    function mostrarResultados(partes,numPartes){
      results.innerHTML = `<h3>üì¶ Archivos Generados (${numPartes} partes)</h3>`;

      partes.forEach(parte=>{
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';

        const info = document.createElement('div');
        info.innerHTML = `<strong>${parte.nombre}</strong><br>${parte.lineas} l√≠neas | ${formatFileSize(parte.contenido.length)}`;

        const btn = document.createElement('button');
        btn.className = 'download-btn';
        btn.textContent = 'Descargar';
        btn.onclick = () => descargarParte(parte.nombre, parte.contenido);

        fileItem.appendChild(info);
        fileItem.appendChild(btn);
        results.appendChild(fileItem);
      });

      if (partes.length > 1) {
        const btnZip = document.createElement('button');
        btnZip.className = 'button success';
        btnZip.textContent = 'üì¶ Descargar todas en ZIP';
        btnZip.onclick = () => descargarZip(partes);
        results.appendChild(btnZip);
      }

      results.classList.add('show');
      showMessage(`Log procesado correctamente en ${numPartes} partes`, 'success');
    }

    function descargarParte(nombre,contenido){
      const blob=new Blob([contenido],{type:"text/plain;charset=utf-8"});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a');
      a.href=url;
      a.download=nombre;
      a.click();
      URL.revokeObjectURL(url);
    }

    async function descargarZip(partes){
      try{
        showMessage('Generando archivo ZIP...','success');
        const zip=new JSZip();
        partes.forEach(p=>zip.file(p.nombre,p.contenido));
        const blob=await zip.generateAsync({type:"blob"});
        const url=URL.createObjectURL(blob);
        const a=document.createElement('a');
        a.href=url;
        a.download="partes_trivial.zip";
        a.click();
        URL.revokeObjectURL(url);
        showMessage('ZIP descargado correctamente','success');
      }catch(e){
        showMessage('Error al generar el archivo ZIP','error');
      }
    }

    function formatFileSize(bytes){
      if(bytes<1024) return bytes+' bytes';
      if(bytes<1048576) return Math.round(bytes/1024)+' KB';
      return Math.round(bytes/1048576)+' MB';
    }

    function showMessage(msg,type){
      const div=document.createElement('div');
      div.className=`message ${type}`;
      div.textContent=msg;
      messages.appendChild(div);
      setTimeout(()=>{ if(div.parentNode){ div.parentNode.removeChild(div); } },5000);
    }
  </script>
</body>
</html>
